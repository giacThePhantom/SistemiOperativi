\chapter{Introduzione}
Un sistema operativo Ã¨ un insieme di programmi che agiscono come intermediario tra l'hardware e l'uomo per facilitare l'uso del computer, rendere efficiente l'uso dell'hardware e evitare conflitti
nell'allocazione di risorse tra hardware e software. Offre pertanto un ambiente per controllare e coordinare l'utilizzo dell'hardware da parte dei programmi applicativi. I suoi compiti principali sono di gestore di
risorse e di controllore dell'esecuzione dei programmi e il corretto utilizzo del sistema. La struttura dei sistemi operativi \`e soggetta a notevole variabilit\`a ad \`e adattabile a criteri di organizzazione estremamente differenti.
\`E pertanto un programma sempre in esecuzione sul calcolatore che generalmente viene chiamato kernel al quale si aggiungono programmi di sistema e programmi applicativi.
\begin{figure}[h]
	\includegraphics[width=\textwidth]{Pictures/StackSistemaOperativo.png}
	\caption{Stack del sistema operativo}
\end{figure}
Nel progettare un sistema operativo si deve tipicamente fare un trade-off tra l'astrazione che semplifica l'utilizzo del sistema e l'efficienza.
\subsubsection{Componenti}
Un sistema di calcolo si pu\`o dividere in $4$ componenti:
\begin{itemize}
	\item Dispositivi fisici: sono composti dall'unit\`a centrale di elaborazione (CPU), dalla memoria e dall'I/O.
	\item Programmi applicativi: definiscono il modo in cui utilizzare le risorse per risolvere i problemi computazionali da parte degli utenti.
	\item Sistema operativo: Controlla e coordina l'udo dei dispositivi da parte degli utenti.
	\item Utenti.
\end{itemize}
\subsection{Punti chiave nel progetto di calcolatori}
\subsubsection{Punto di vista dell'utente}
La percezione di un calcolatore dipende dall'interfaccia impiegata. Il pi\`u comune metodo di utilizzo \`e il PC composto da schermo, tastiera e mouse. Il sistema operativo in questo caso si progetta considerando la facilit\`a di
utilizzo con qualche attenzione alle prestazioni ma non all'utilizzo delle risorse. Nel caso di un utente che utilizza terminali connessi ad un mainframe condividendo risorse con altri utenti il sistema operativo andrebbe ottimizzato
per massimizzare l'utilizzo delle risore.
\subsubsection{Punto di vista del sistema}
Il sistema operativo \`e il programma collegato pi\`u strettamente ai suoi elementi fisici ed \`e assimilabile ad un assegnatore di risorse o come programma di controllo che gestisce l'esecuzione dei programmi utente in modo da
impedire che si verifichino errori o che il calcolatore sia utilizzato in modo scorretto.
\section{Storia dei sistemi operativi}
Si possono identificare 5 generazioni di calcolatori che riflettono direttamente l'evoluzione dei sistemi operativi dovuta all'aumento dell'utilizzo del processore.
\subsection{Prima generazione (1946-1955)}
In questa generazione i calcolatori erano enormi e a valvole, non esisteva il sistema operativo e l'operatore del calcolatore era equivalente al programmatore. L'accesso alla macchina era gestito tramite
prenotazioni e i programmi venivano eseguiti da console caricando in memoria un'istruzione alla volta agendo su interruttori. Il controllo degli errori era fatto attraverso spie della console. Il processing era
seriale.
\subsubsection{Evoluzione}
Durante la prima generazione si diffondono periferiche come il lettore/perforatore di schede, nastri e stampanti che rendono necessari programmi di interazione con periferiche detti device driver. Viene
sviluppato del software come librerie di funzioni comuni e compilatori, linker e loader. Queste evoluzioni portano a una scarsa efficienza in quanto pur essendo la programmazione facilitata le operazioni erano
complesse con tempi di setup elevati e un basso utilizzo relativo della CPU per eseguire il programma.
\subsection{Seconda generazione (1955-1965)}
In questa generazione si introducono i transistor nei calcolatori. Viene separato il ruolo di programmatore e operatore eliminando lo schema  a prenotazione e il secondo permette di eliminare dei tempi morti.
I programmi o jobs simili nell'esecuzione vengono raggruppati in batch in modo da aumentare l'efficienza ma aumentando i problemi in caso di errori o malfunzionamenti.
\subsubsection{Evoluzione}
Nasce l'automatic job sequencing in cui il sistema si occupa di passare da un job all'altro: il sistema operativo fa il lavoro dell'operatore e rimuove i tempi morti. Nasce pertanto il monitor residente, il primo
esempio di sistema operativo, perennemente caricato in memoria. Le componenti del monitor erano i driver per i dispositivi di I/O, il sequenzializzatore dei job e l'interprete delle schede di controllo (per la loro
lettura ed esecuzione). La sequenzializzazione avviene tramite un linguaggio di controllo o job control language attraverso schede o record di controllo.
\subsubsection{Limitazioni}
L'utilizzo del sistema risulta ancora basso a causa del divario di velocit\`a tra I/O e CPU. Una soluzione \`e la sovrapposizione delle operazioni di I/O e di elaborazione. Nasce cos\`i l'elaborazione off-line grazie
alla diffusione di nastri magnetici capienti e veloci. La sovrapposizione avviene su macchine diverse: da scheda a nastro su una macchina e da nastro a CPU su un'altra. La CPU viene limitata ora dalla velocit\`a dei
nastri, maggiore di quella delle schede.
\subsubsection{Sovrapposizione tra CPU e I/O}
\`E possibile attraverso un opportuno supporto strutturale far risiedere sulla macchina le operazioni off-line di I/O e CPU.
\paragraph{Polling}
Il polling \`e il meccanismo tradizionale di interazione tra CPU e I/O: avviene l'interrogazione continua del dispositivo tramite esplicite istruzioni bloccanti. Per sovrapporre CPU e I/O \`e necessario un
meccanismo asincrono o richiesta  I/O non bloccante come le interruzioni o interrupt e il DMA (direct memory access).
\paragraph{Interrupt e I/O}
In questo caso la CPU programma il dispositivo e contemporaneamente il dispositivo controllore esegue. La CPU, se possibile prosegue l'elaborazione. Il dispositivo segnala la fine dell'elaborazione alla CPU. La
CPU riceve un segnale di interrupt esplicito e interrompe l'istruzione corrente salvando lo stato, salta a una locazione predefinita, serve l'interruzione trasferendo i dati e riprende l'istruzione interrotta.
\paragraph{DMA e I/O}
Nel caso di dispositivi veloci gli interrupt sono molto frequenti e porterebbero a inefficienza. Si rende pertanto necessario creare uno specifico controllore hardware detto DMA controller che si occupa del
trasferimento di blocchi di dati tra I/O e memoria senza interessare la CPU. Avviene pertanto un solo interrupt per blocco di dati.
\paragraph{Buffering}
Si dice buffering la sovrapposizione di CPU e I/O dello stesso job. Il dispositivo di I/O legge o scrive pi\`u dati di quanti richiesti e risulta utile quando la velocit\`a dell'I/O e della CPU sono simili. Nella realt\`a i
dispositivi di I/O sono pi\`u lenti della CPU e pertanto il miglioramento \`e marginale.
\paragraph{Spooling}
Si dice spooling (simultaneous peripheral operations on-line) )la sovrapposizione di CPU e I/O di job diversi, Nasce un problema in quanto i nastri magnetici sono sequenziali e pertanto il lettore di schede non
pu\`o scrivere su un'estremit\`a del nastro mentre la CPU legge dall'altra. Si devono pertanto introdurre dischi magnetici ad accesso causale. Il disco viene utilizzato come un buffer unico per tutti i job. Nasce
il paradigma moderno di programma su disco che viene caricato in memoria, la pool di job e il concetto di job scheduling (la decisione di chi deve o pu\`o essere caricato su disco).
\subsection{Terza generazione (1965-1980)}
In questa generazione viene introdotta la multiprogrammazione e i circuiti integrati. La prima nasce dal fatto che un singolo job \`e incapace di tener sufficientemente occupata la CPU e pertanto si rende
necessaria una loro competizione. Sono presenti pi\`u job in memoria e le fasi di attesa vengono sfruttate per l'esecuzione di un nuovo job.
Con la presenza di pi\`u job nel sistema diventa possibile modificare la natura dei sistemi operativi: si passa ad una tendenza a sodisfare molti utenti che
operano interattivamente e diventa importante il tempo di risposta di un job (quanto ci vuole perch\`e inizi la sua esecuzione). Nasce pertanto il
multitasking o time sharing, estensione logica della multiprogrammazione in cui l'utente ha l'impressione di avere la macchina solo per s\`e e si migliora
l'interattivit\`a con la gestione di errori e l'analisi di risultati. Nascono i sistemi moderni con tastiera che permette decisioni dell'evoluzione del
sistema in base ai comandi dell'utente e un monitor che permette un output immediato durante l'esecuzione. Il file system inoltre \`e un'astrazione del
sistema operativo per accedere a dati e programmi.
\subsubsection{Protezione}
Con la condivisione si rende necessario introdurre delle capacit\`a di protezione per il sistema:
\begin{itemize}
	\item I/O: programmi diversi non devono usare il dispositivo contemporaneamente, viene realizzata tramite il modo duale di esecuzione: modo user in cui i
	      job non possono accedere direttamente alle risorse di I/O e modo supervisor o kernel in cui il sistema operativo pu\`o accedere a tali risorse. Tutte le
	      operazioni di I/O sono privilegiate: le istruzioni di accesso invocano una system call, un interrupt software che cambia la modalit\`a da user a supervisor
	      e al termine della system call viene ripristinata la modalit\`a supervisor.
	\item Memoria: un programma non pu\`o leggere o scrivere ad una zona di memoria che non gli appartiene: realizzata associando dei registri limite ad ogni
	      processo, che possono essere modificati unicamente dal sistema operativo con istruzioni privilegiate.
	\item CPU: prima o poi il controllo della CPU deve tornare al sistema operativo, realizzata attraverso un timer legato ad un job, al termine del quale il
	      controllo passa al monitor.
\end{itemize}
\subsection{Quarta generazione (1980-1990)}
\begin{itemize}
	\item Diffusione di sistemi operativi per PC e workstation, utilizzo personale degli elaboratori e nascita delle interfacce grafiche (GUI).
	\item Sistemi operativi di rete in cui esiste una separazione logica delle risorse remote in cui l'accesso alle risorse remote \`e diverso rispetto a quello
	      delle risorse locali.
	\item Sistemi operativi distribuiti: le risorse remote non sono separate logicamente e l'accesso alle risorse remote e locali \`e uguale.
\end{itemize}
\subsubsection{Quinta generazione (1990- oggi)}
Sistemi real-time vincolati sui tempi di risposta del sistema, sistemi operativi embedded per applicazioni specifiche, per piattaforme mobili e per
l'internet of things.
